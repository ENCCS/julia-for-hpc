<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Multithreading &mdash; Julia for High-Performance Scientific Computing</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" type="text/css" />
      <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../_static/togglebutton.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sphinx_lesson.css" type="text/css" />
      <link rel="stylesheet" href="../_static/overrides.css" type="text/css" />
      <link rel="stylesheet" href="../_static/tabs.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script src="../_static/minipres.js"></script>
        <script src="../_static/tabs.js"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../_static/togglebutton.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex/" />
    <link rel="search" title="Search" href="../search/" />
    <link rel="next" title="Distributed computing" href="../distributed/" />
    <link rel="prev" title="Writing performant Julia code" href="../performant-code/" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../" class="icon icon-home">
            Julia for High-Performance Scientific Computing
              <img src="../_static/ENCCS.jpg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Prerequisites</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../setup/">Setup</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">The lesson</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../motivation/">Motivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../performant-code/">Writing performant Julia code</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Multithreading</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#threading">Threading</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pitfalls">Pitfalls</a></li>
<li class="toctree-l3"><a class="reference internal" href="#floops">FLoops</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">Exercises</a></li>
<li class="toctree-l2"><a class="reference internal" href="#see-also">See also</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../distributed/">Distributed computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dagger/">Dagger</a></li>
<li class="toctree-l1"><a class="reference internal" href="../MPI/">Message passing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cluster/">Running on a cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GPU/">GPU programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../interfacing/">Interfacing to C and Fortran</a></li>
<li class="toctree-l1"><a class="reference internal" href="../conclusions/">Summary and outlook</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Optional episodes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../exercises/">Advanced exercises</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../guide/">Instructor’s guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../">Julia for High-Performance Scientific Computing</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Multithreading</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/enccs/Julia-for-HPC/blob/master/content/multithreading.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="multithreading">
<h1>Multithreading<a class="headerlink" href="#multithreading" title="Permalink to this heading"></a></h1>
<div class="admonition-questions questions admonition" id="questions-0">
<p class="admonition-title">Questions</p>
<ul class="simple">
<li><p>What parallelization options exist in Julia?</p></li>
<li><p>What is multithreading?</p></li>
</ul>
</div>
<div class="admonition-instructor-note instructor-note admonition" id="instructor-note-0">
<p class="admonition-title">Instructor note</p>
<ul class="simple">
<li><p>20 min teaching</p></li>
<li><p>20 min exercises</p></li>
</ul>
</div>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<p>Julia has inbuilt automatic parallelism which is useful to know about.
Consider the multiplication of two large array:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">A</span><span class="o">*</span><span class="n">B</span>
</pre></div>
</div>
<p>If we run this in a Julia session and monitor the resource usage (e.g. via <code class="docutils literal notranslate"><span class="pre">top</span></code>)
we can see that all cores on our computers are used!</p>
<p>But to go beyond that, Julia supports four main types of parallel programming:</p>
<ul class="simple">
<li><p><strong>Asynchronous tasks or coroutines</strong>: Tasks allow suspending and resuming
computations for I/O, event handling and similar patterns. Not really HPC and
outside the scope of the this lesson.</p></li>
<li><p><strong>Multi-threading</strong>: Provides the ability to schedule Tasks simultaneously
on more than one thread or CPU core, sharing memory. The easiest way to parallelize
on shared-memory systems. Contained in the <code class="docutils literal notranslate"><span class="pre">Threads</span></code> standard library.</p></li>
<li><p><strong>Distributed computing</strong>: Runs multiple Julia processes with separate memory
spaces on the same or multiple computers. Useful high-level constructs are implemented
in the standard library <code class="docutils literal notranslate"><span class="pre">Distributed</span></code> module. For those that like MPI there is
<a class="reference external" href="https://github.com/JuliaParallel/MPI.jl">MPI.jl</a>.</p></li>
<li><p><strong>GPU computing</strong>: Ports computation to a graphical processing unit (GPU) via either high-level
or low-level programming.</p></li>
</ul>
</section>
<section id="threading">
<h2>Threading<a class="headerlink" href="#threading" title="Permalink to this heading"></a></h2>
<p>We start by walking through how to use multithreading in Julia.
In the VSCode REPL, let’s see how many threads we have access to:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">Threads</span><span class="o">.</span><span class="n">nthreads</span><span class="p">()</span>
</pre></div>
</div>
<p>Hmm, but we need more than one thread to be able to gain any performance
from multithreading.</p>
<p>Julia can be started with a given number of threads in two ways:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>julia<span class="w"> </span>-t<span class="w"> </span><span class="m">4</span>
julia<span class="w"> </span>-t<span class="w"> </span>auto
<span class="c1"># or (can also set the env-var in e.g. .bashrc)</span>
<span class="nv">JULIA_NUM_THREADS</span><span class="o">=</span><span class="m">4</span><span class="w"> </span>julia
</pre></div>
</div>
<p>This is not possible to do inside VSCode. Instead, we open up the
“Extension Settings” for the Julia VSCode extension and set the
“Julia: Num Threads” setting to the number of CPU cores we have on
our machines (if you’re unsure, just try setting it to 2).
After updating the number of threads we need to restart the VSCode REPL.
We can make sure we have access to the correct number of threads
with the <code class="docutils literal notranslate"><span class="pre">Threads.nthreads()</span></code> function.</p>
<p>The main multithreading approach is to use the <code class="docutils literal notranslate"><span class="pre">Threads.&#64;threads</span></code> macro
which parallelizes a <cite>for</cite> loop to run with multiple threads:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">.</span><span class="n">Threads</span>
<span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="nd">@threads</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="mi">10</span>
<span class="w">    </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadid</span><span class="p">()</span>
<span class="k">end</span>
<span class="n">println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s see if we can achieve any speed gain when performing a
costly calculation.</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-0-0-0" aria-selected="true" class="sphinx-tabs-tab" id="tab-0-0-0" name="0-0" role="tab" tabindex="0">Serial</button><button aria-controls="panel-0-0-1" aria-selected="false" class="sphinx-tabs-tab" id="tab-0-0-1" name="0-1" role="tab" tabindex="-1">Threaded</button></div><div aria-labelledby="tab-0-0-0" class="sphinx-tabs-panel" id="panel-0-0-0" name="0-0" role="tabpanel" tabindex="0"><div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="n">sqrt_array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="w">    </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">similar</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">eachindex</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="w">        </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="n">B</span>
<span class="k">end</span>
</pre></div>
</div>
</div><div aria-labelledby="tab-0-0-1" class="sphinx-tabs-panel" hidden="true" id="panel-0-0-1" name="0-1" role="tabpanel" tabindex="0"><div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="n">threaded_sqrt_array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="w">    </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">similar</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="w">    </span><span class="nd">@threads</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">eachindex</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="w">        </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="n">B</span>
<span class="k">end</span>
</pre></div>
</div>
</div></div>
<p>We can now compare the performance:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="p">)</span>
<span class="nd">@btime</span><span class="w"> </span><span class="n">sqrt_array</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="nd">@btime</span><span class="w"> </span><span class="n">threaded_sqrt_array</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>

<span class="c"># make sure we&#39;re getting the correct value</span>
<span class="n">sqrt_array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="o">≈</span><span class="w"> </span><span class="n">threaded_sqrt_array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<p>With 4 threads, the speedup could be about a factor of 3.</p>
<div class="admonition-threading-overhead callout admonition" id="callout-0">
<p class="admonition-title">Threading overhead</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">Threads.&#64;threads</span></code> has an overhead of a few microseconds (equivalent to thousands of computations),
so threading is most efficient for time consuming jobs.</p>
</div>
<section id="pitfalls">
<h3>Pitfalls<a class="headerlink" href="#pitfalls" title="Permalink to this heading"></a></h3>
<p>Just like with multithreading in other languages, one needs to be
aware of possible <a class="reference external" href="https://en.wikipedia.org/wiki/Race_condition">race conditions</a>,
i.e. when the order in which threads read from and write to memory
can change the result of a computation.</p>
<p>We can illustrate this with an example where we sum up the square
root of elements of an array. The serial version provides the correct
value and reference execution time. The “race condition” version illustrates
how a naive implementation can lead to problems. The “atomic” version shows
how we can ensure a correct results by using <cite>atomic operations</cite>.
The “workaround” version shows how we can refactor the code to get both
correct result and speedup.</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-1-1-0" aria-selected="true" class="sphinx-tabs-tab" id="tab-1-1-0" name="1-0" role="tab" tabindex="0">Serial</button><button aria-controls="panel-1-1-1" aria-selected="false" class="sphinx-tabs-tab" id="tab-1-1-1" name="1-1" role="tab" tabindex="-1">Race condition</button><button aria-controls="panel-1-1-2" aria-selected="false" class="sphinx-tabs-tab" id="tab-1-1-2" name="1-2" role="tab" tabindex="-1">Atomic</button><button aria-controls="panel-1-1-3" aria-selected="false" class="sphinx-tabs-tab" id="tab-1-1-3" name="1-3" role="tab" tabindex="-1">Workaround</button></div><div aria-labelledby="tab-1-1-0" class="sphinx-tabs-panel" id="panel-1-1-0" name="1-0" role="tabpanel" tabindex="0"><div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="n">sqrt_sum</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span><span class="p">(</span><span class="n">eltype</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">eachindex</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="w">        </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">s</span>
<span class="k">end</span>
</pre></div>
</div>
</div><div aria-labelledby="tab-1-1-1" class="sphinx-tabs-panel" hidden="true" id="panel-1-1-1" name="1-1" role="tabpanel" tabindex="0"><div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="n">threaded_sqrt_sum</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span><span class="p">(</span><span class="n">eltype</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="w">    </span><span class="nd">@threads</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">eachindex</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="w">        </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">s</span>
<span class="k">end</span>
</pre></div>
</div>
</div><div aria-labelledby="tab-1-1-2" class="sphinx-tabs-panel" hidden="true" id="panel-1-1-2" name="1-2" role="tabpanel" tabindex="0"><div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="n">threaded_sqrt_sum_atomic</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">Atomic</span><span class="p">{</span><span class="kt">eltype</span><span class="p">(</span><span class="kt">A</span><span class="p">)}(</span><span class="n">zero</span><span class="p">(</span><span class="n">eltype</span><span class="p">(</span><span class="n">A</span><span class="p">)))</span>
<span class="w">    </span><span class="nd">@threads</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">eachindex</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="w">        </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">atomic_add!</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">[]</span>
<span class="k">end</span>
</pre></div>
</div>
</div><div aria-labelledby="tab-1-1-3" class="sphinx-tabs-panel" hidden="true" id="panel-1-1-3" name="1-3" role="tabpanel" tabindex="0"><div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="n">threaded_sqrt_sum_workaround</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="w">    </span><span class="n">partial</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zeros</span><span class="p">(</span><span class="n">eltype</span><span class="p">(</span><span class="n">A</span><span class="p">),</span><span class="w"> </span><span class="n">nthreads</span><span class="p">())</span>
<span class="w">    </span><span class="nd">@threads</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">eachindex</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="w">        </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">partial</span><span class="p">[</span><span class="n">threadid</span><span class="p">()]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero</span><span class="p">(</span><span class="n">eltype</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">eachindex</span><span class="p">(</span><span class="n">partial</span><span class="p">)</span>
<span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">partial</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">s</span>
<span class="k">end</span>
</pre></div>
</div>
</div></div>
<p>We will observe that:</p>
<ul class="simple">
<li><p>The serial version is slow but correct.</p></li>
<li><p>The race condition version is both slow and wrong.</p></li>
<li><p>The atomic version is correct but extremely slow.</p></li>
<li><p>The workaround is fast and correct, but required refactoring.</p></li>
</ul>
<p>Bonus questions:</p>
<ul class="simple">
<li><p>What does <code class="xref py py-meth docutils literal notranslate"><span class="pre">eltype()</span></code> do?</p></li>
<li><p>What does <code class="xref py py-meth docutils literal notranslate"><span class="pre">eachindex()</span></code> do?</p></li>
</ul>
<p>Threading with <code class="docutils literal notranslate"><span class="pre">Threads.&#64;threads</span></code> is quite straightforward,
but one needs to be careful not to introduce race conditions
and sometimes that requires code refactorization. Using atomic operations
adds significant overhead and thus only makes sense if each iteration
of the loop takes significant time to compute.</p>
</section>
<section id="floops">
<h3>FLoops<a class="headerlink" href="#floops" title="Permalink to this heading"></a></h3>
<p><a class="reference external" href="https://github.com/JuliaFolds/FLoops.jl">FLoops.jl</a> is a a more recent
package for threading. It provides a macro <code class="docutils literal notranslate"><span class="pre">&#64;floop</span></code> which is a superset of <code class="docutils literal notranslate"><span class="pre">Threads.&#64;threads</span></code>
and can be used to generate fast generic sequential and parallel iteration over more
complex collections than what can be done with <code class="docutils literal notranslate"><span class="pre">Threads.&#64;threads</span></code>.
<code class="docutils literal notranslate"><span class="pre">&#64;floop</span></code> can also do reductions and supports multiple threading backends through
<a class="reference external" href="FoldsThreads.jl">FoldsThreads.jl</a> and even <a class="reference external" href="https://github.com/JuliaFolds/FoldsCUDA.jl">FoldsCUDA.jl</a> for running on GPUs.</p>
</section>
</section>
<section id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading"></a></h2>
<div class="admonition-multithreading-the-laplace-function exercise important admonition" id="exercise-0">
<p class="admonition-title">Multithreading the Laplace function</p>
<p>Consider the double for loop in the <code class="xref py py-meth docutils literal notranslate"><span class="pre">lap2d!()</span></code> function:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="n">lap2d!</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">unew</span><span class="p">)</span>
<span class="w">    </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span>
<span class="w">            </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">unew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.25</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="w">        </span><span class="k">end</span><span class="w"> </span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Can it safely be threaded, i.e. is there any risk of race
conditions?</p>
<div class="admonition-is-it-thread-safe solution important dropdown admonition" id="solution-0">
<p class="admonition-title">Is it thread-safe?</p>
<p>Yes, this function is thread-safe since each iteration of the loop accesses a different memory location.</p>
</div>
<ul>
<li><p>Insert the <code class="docutils literal notranslate"><span class="pre">Threads.&#64;threads</span></code> macro in the right location -
note that <code class="docutils literal notranslate"><span class="pre">&#64;threads</span></code> currently only works on outermost loops!</p></li>
<li><p>Measure its effects with <code class="docutils literal notranslate"><span class="pre">&#64;benchmark</span></code>.
Since it’s cumbersome to change the “Julia: Num Threads” option
in VSCode and relaunch the Julia REPL over and over, create a script instead
which imports <cite>BenchmarkTools</cite> and prints benchmark results:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">bench_results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nd">@benchmark</span><span class="w"> </span><span class="n">lap2d!</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">unew</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="n">minimum</span><span class="p">(</span><span class="n">bench_results</span><span class="o">.</span><span class="n">times</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p>Now run with different number of threads from a terminal using
<code class="docutils literal notranslate"><span class="pre">julia</span> <span class="pre">-t</span> <span class="pre">&lt;N&gt;</span> <span class="pre">laplace.jl</span></code> and observe the scaling.</p></li>
<li><p>Try increasing the problem size (e.g. <code class="docutils literal notranslate"><span class="pre">M=N=8192</span></code>). Does it scale better?</p></li>
</ul>
<div class="admonition-solution solution important dropdown admonition" id="solution-1">
<p class="admonition-title">Solution</p>
<p>Multithreaded version:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">.</span><span class="n">Threads</span>

<span class="k">function</span><span class="w"> </span><span class="n">lap2d!</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">unew</span><span class="p">)</span>
<span class="w">    </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="w">    </span><span class="nd">@threads</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span>
<span class="w">            </span><span class="nd">@inbounds</span><span class="w"> </span><span class="n">unew</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.25</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="w">        </span><span class="k">end</span><span class="w"> </span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Benchmarking:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="n">setup</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="o">=</span><span class="mi">4096</span><span class="p">)</span>
<span class="w">    </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">)</span>
<span class="w">    </span><span class="c"># set boundary conditions</span>
<span class="w">    </span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">:</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="k">end</span><span class="p">,</span><span class="o">:</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="k">end</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="mf">10.0</span>
<span class="w">    </span><span class="n">unew</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">copy</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">unew</span>
<span class="k">end</span>

<span class="k">using</span><span class="w"> </span><span class="n">BenchmarkTools</span>

<span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">unew</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">setup</span><span class="p">()</span>
<span class="n">bench_results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nd">@benchmark</span><span class="w"> </span><span class="n">lap2d!</span><span class="p">(</span><span class="o">$</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="o">$</span><span class="n">unew</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;time = </span><span class="si">$</span><span class="p">(</span><span class="n">minimum</span><span class="p">(</span><span class="n">bench_results</span><span class="o">.</span><span class="n">times</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="o">^</span><span class="mi">6</span><span class="p">)</span><span class="s">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>julia<span class="w"> </span>-t<span class="w"> </span><span class="m">1</span><span class="w"> </span>laplace.jl
<span class="gp"># </span><span class="nb">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">7</span>.440875

<span class="gp">$ </span>julia<span class="w"> </span>-t<span class="w"> </span><span class="m">2</span><span class="w"> </span>laplace.jl
<span class="gp"># </span><span class="nb">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">4</span>.559292

<span class="gp">$ </span>julia<span class="w"> </span>-t<span class="w"> </span><span class="m">4</span><span class="w"> </span>laplace.jl
<span class="gp"># </span><span class="nb">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3</span>.802625
</pre></div>
</div>
<p>Increasing the problem size will not improve the parallel efficiency as it does not
increase the computational cost in the loop.</p>
</div>
</div>
<div class="admonition-multithread-the-computation-of exercise important admonition" id="exercise-1">
<p class="admonition-title">Multithread the computation of π</p>
<figure class="align-right">
<a class="reference internal image-reference" href="../_images/pi_with_darts.png"><img alt="../_images/pi_with_darts.png" src="../_images/pi_with_darts.png" style="width: 168.00000000000003px; height: 126.00000000000001px;" /></a>
</figure>
<p>Consider the following function which estimates π by “throwing darts”,
i.e. randomly sampling (x,y) points in the interval [0.0, 1.0] and checking
if they fall within the unit circle.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="n">estimate_pi</span><span class="p">(</span><span class="n">num_points</span><span class="p">)</span>
<span class="w">    </span><span class="n">hits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="n">num_points</span>
<span class="w">        </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span><span class="p">(),</span><span class="w"> </span><span class="n">rand</span><span class="p">()</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1.0</span>
<span class="w">            </span><span class="n">hits</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="n">fraction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hits</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">num_points</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fraction</span>
<span class="k">end</span>
</pre></div>
</div>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">num_points</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100_000_000</span>
<span class="n">estimate_pi</span><span class="p">(</span><span class="n">num_points</span><span class="p">)</span><span class="w">  </span><span class="c"># 3.14147572...</span>
</pre></div>
</div>
<p>Can this function be safely threaded, i.e. is there any risk of race
conditions?</p>
<div class="admonition-is-it-thread-safe solution important dropdown admonition" id="solution-2">
<p class="admonition-title">Is it thread-safe?</p>
<p>No, this function is not thread-safe! The algorithm needs to be rewritten.</p>
</div>
<ul class="simple">
<li><p>Define a new function <code class="xref py py-meth docutils literal notranslate"><span class="pre">threaded_estimate_pi()</span></code> where you implement the necessary changes
to multithread the loop.</p></li>
<li><p>Run some benchmarks to explore the parallel efficiency.</p></li>
</ul>
<div class="admonition-hint solution important dropdown admonition" id="solution-3">
<p class="admonition-title">Hint</p>
<p>You need to make sure that the different threads are not incrementing the same memory address.
One can for example define a <code class="docutils literal notranslate"><span class="pre">partial_hits</span></code> array and increment its indices in the for loop:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">partial_hits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zeros</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="n">nthreads</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="admonition-solution solution important dropdown admonition" id="solution-4">
<p class="admonition-title">Solution</p>
<p>Here is a threaded version:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">.</span><span class="n">Threads</span>

<span class="k">function</span><span class="w"> </span><span class="n">threaded_estimate_pi</span><span class="p">(</span><span class="n">num_points</span><span class="p">)</span>
<span class="w">    </span><span class="n">partial_hits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zeros</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="n">nthreads</span><span class="p">())</span>

<span class="w">    </span><span class="nd">@threads</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="n">num_points</span>
<span class="w">        </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span><span class="p">(),</span><span class="w"> </span><span class="n">rand</span><span class="p">()</span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1.0</span>
<span class="w">            </span><span class="n">partial_hits</span><span class="p">[</span><span class="n">threadid</span><span class="p">()]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">	</span><span class="k">end</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="n">hits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">partial_hits</span><span class="p">)</span>

<span class="w">    </span><span class="n">fraction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hits</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">num_points</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fraction</span>
<span class="k">end</span>
</pre></div>
</div>
<p>To benchmark it:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">BenchmarkTools</span>

<span class="n">num_points</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100_000_000</span>
<span class="c"># make sure we get an accurate estimate:</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;pi = </span><span class="si">$</span><span class="p">(</span><span class="n">threaded_estimate_pi</span><span class="p">(</span><span class="n">num_points</span><span class="p">))</span><span class="s">&quot;</span><span class="p">)</span>

<span class="n">bench_results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nd">@benchmark</span><span class="w"> </span><span class="n">threaded_estimate_pi</span><span class="p">(</span><span class="o">$</span><span class="n">num_points</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;time = </span><span class="si">$</span><span class="p">(</span><span class="n">minimum</span><span class="p">(</span><span class="n">bench_results</span><span class="o">.</span><span class="n">times</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="o">^</span><span class="mi">6</span><span class="p">)</span><span class="s">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Results:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>julia<span class="w"> </span>-t<span class="w"> </span><span class="m">1</span><span class="w"> </span>threaded_estimate_pi.jl
<span class="gp"># </span><span class="nv">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3</span>.14147464
<span class="gp"># </span><span class="nb">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">496</span>.935583

<span class="gp">$ </span>julia<span class="w"> </span>-t<span class="w"> </span><span class="m">2</span><span class="w"> </span>threaded_estimate_pi.jl
<span class="gp"># </span><span class="nv">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3</span>.1417046
<span class="gp"># </span><span class="nb">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">255</span>.328

<span class="gp">$ </span>julia<span class="w"> </span>-t<span class="w"> </span><span class="m">4</span><span class="w"> </span>threaded_estimate_pi.jl
<span class="gp"># </span><span class="nv">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3</span>.14172796
<span class="gp"># </span><span class="nb">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">132</span>.892833
</pre></div>
</div>
<p>Parallel scaling seems decent, but comparing to the unthreaded version reveals the overhead
from creating and managing threads:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>julia<span class="w"> </span>estimate_pi.jl
<span class="gp"># </span><span class="nv">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3</span>.14147392
<span class="gp"># </span><span class="nb">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">228</span>.434583
</pre></div>
</div>
</div>
</div>
</section>
<section id="see-also">
<h2>See also<a class="headerlink" href="#see-also" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p>The <a class="reference external" href="https://github.com/JuliaParallel">Julia Parallel</a> organization collects
packages developed for parallel computing in Julia.</p></li>
<li><p><a class="reference external" href="https://docs.julialang.org/en/v1/manual/multi-threading/">Multi-threading docs</a></p></li>
</ul>
<div class="admonition-keypoints keypoints admonition" id="keypoints-0">
<p class="admonition-title">Keypoints</p>
<ul class="simple">
<li><p>One should choose a distributed mechanism that fits with the
time and memory parameters of your problem</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Threads</span></code> is as easy as decorating for loops with <code class="docutils literal notranslate"><span class="pre">&#64;threads</span></code>, but data
dependencies (race conditions) need to be avoided.</p></li>
</ul>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../performant-code/" class="btn btn-neutral float-left" title="Writing performant Julia code" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../distributed/" class="btn btn-neutral float-right" title="Distributed computing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, EuroCC National Competence Center Sweden.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>