Interfacing to C and Fortran
============================

.. questions::

   - 1.
   - 2.

.. instructor-note::

   - 20 min teaching
   - 20 min exercises


Why Julia interfacing with other languages?
-------------------------------------------

One of the most significant advantages of Julia is its speed. As we have shown in the Episode
`Motivation <https://enccs.github.io/julia-for-hpc/motivation/#speed>`_, Julia is fast out-of-box
without the necessity to do any additional steps. As such, Julia solves the so-called **two-Language problem**.

Since Julia is fast enough, most of the libraries are written in pure Julia, and there is no need to use C or Fortran for performance.
However, there are many high-quality, mature libraries for numerical computing already written in C and Fortran.
It would be resource-wasting if it is not possible to use them in Julia.

In fact, to allow easy use of existing C and Fortran code, Julia has native support for calling C and Fortran functions.
Julia has a **no boilerplate** philosophy: *functions can be called directly from Julia without any glue code generation
or compilation – even from the interactive prompt*.

In this episode, we will show examples of Julia interfacing with C and Fortran.
Extensive description of all provided functionality can be found in the
`official manual <https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/>`_.


Interfacing Julia with C
------------------------

The interfacing of Julia with C and Fortran is accomplished by making an appropriate call with
the ``ccall`` syntax, which looks like an ordinary function call.

The C and Fortran code to be called must be available as a shared library.
Most C and Fortran libraries ship compiled as shared libraries already.
However, if you want to compile the code yourself using `GCC` (or `Clang`),
you will need to use the `-shared` and `-fPIC` options.
The machine instructions generated by Julia's JIT are the same as a native C call would be,
so the resulting overhead is the same as calling a library function from C code.

By default, Fortran compilers generate mangled names (for example, converting function names to lowercase or uppercase,
often appending an underscore), and so to call a Fortran function you must pass the mangled identifier corresponding
to the rule followed by your Fortran compiler. When calling a Fortran function, all inputs must be passed as pointers
to allocated values on the heap or stack. This applies not only to arrays and other mutable objects which are normally
heap-allocated, but also to scalar values such as integers and floats which are normally stack-allocated and commonly
passed in registers when using C or Julia calling conventions.

When calling C and Fortran functions, the name of the function and the library it lives in
are passed as a tuple in the first argument, followed by the return type of the function and the types
of the function arguments, and finally the argument themselves. It’s a bit klunky, but it works!

Here is one example to calculate the square root of a number (herein, it is 64.0).

.. code-block:: julia

    julia> ccall((:sqrt, "libm"), Float64, (Float64,), 64.0)

It also makes sense to wrap a call like that in a native Julia function.

.. code-block:: julia

    julia> csqrt(x) = ccall((:sqrt, "libm"), Float64, (Float64,), x);
    julia> csqrt(81.0)



The following example is adapted from `Calling C from Julia <https://craftofcoding.wordpress.com/2017/02/08/calling-c-from-julia-i-simple-arrays/>`_ by `The Craft of Coding`.
Let's conside the following C function which computes the mean from an array of integer values.
We will name the file as :code:`mean.c`.

.. code-block:: c

   double vectorMean(int *arr, int n)
   {
       int i, sum=0;
       double mean;
       for (i=0; i<n; i=i+1)
           sum = sum + arr[i];
       mean = sum / (double)n;
       return mean;
   }

Next, we need to compile the code in :code:`mean.c` into a shared object named as :code:`mean.so`.
We use the GNU C compiler (GCC) with the flags :code:`-Wall` to enable warnings, :code:`-fpic` to make the shared object relocatable and :code:`-shared` to produce a shared object.
A collection of shared objects is usually referred to as a library.

.. code-block:: bash

   gcc -Wall -fpic -shared -o mean.so mean.c

Now, we can call the shared object from Julia using the :code:`ccall` function as
follows:

.. code-block:: julia

   # Define the array in Julia
   arr = [1,2,3,4,5]

   # Length of the array
   n = length(arr_c)

   # Convert the inputs to native C integer types
   arr_c = collect(Cint, arr)
   n_c = convert(Cint, n)

   # Call the shared library
   ccall((:vectorMean, "./mean.so"), Cdouble, (Ptr{Cint}, Cint), arr_c, n_c)



Interfacing Julia with Fortran
------------------------------

During the compilation, the Fortran compilers usually generate mangled names by appending an underscore to the lowercased/uppercased function names.
Therefore, if you want to call a Fortran function using Julia, you must pass the mangled identifier corresponding to the rule followed by your Fortran compiler.
In addition, all inputs must be passed by reference when calling a Fortran function.

Below we provide an example for interfacing Julia with Frotran.

.. code-block:: fortran

   # fortran_julia.f90
   module fortran_julia
      implicit none
      public
      contains

      real(8) function add(a, b)
         implicit none
         real(8), intent(in)  :: a, b
         add = a + b
         return
      end function add

      subroutine addsub(x, y, a, b)
         implicit none
         real(8), intent(out) :: x, y
         real(8), intent(in)  :: a, b
         x = a + b
         y = a - b
         return
      end subroutine addsub

      subroutine concatenate(x, a, b)
         implicit none
         character(*), intent(out) :: x
         character(*), intent(in)  :: a, b
         x = a // b
         return
      end subroutine concatenate

      subroutine add_array(x, a, b, n)
         implicit none
         integer, intent(in)  :: n
         real(8), intent(out) :: x(n)
         real(8), intent(in)  :: a(n), b(n)
         x = a + b
         return
      end subroutine add_array

   end module fortran_julia

Then we compile the code :code:`fortran_julia.f90` using  into a shared object named as :code:`fortran_julia.so`.
The flags

.. code-block:: bash

   gfortran fortran_julia.f90 -O3 -shared -fPIC -o fortran_julia.so

Next we can call the shared object from Julia using the :code:`ccall` function:

.. code-block:: julia

   julia> ccall((:__fortran_julia_MOD_add, "fortran_julia.so"), Float64, (Ref{Float64}, Ref{Float64}), 1.1, 3.5)
   4.6

In addition, the `add` function in the Fortran module can be further wrapped in the following Julia function to simplify the calling convension.

.. code-block:: julia

   julia> function add(a::Float64, b::Float64)
              ccall((:__fortran_julia_MOD_add, "fortran_julia.so"), Float64, (Ref{Float64}, Ref{Float64}), a, b)
          end
   add (generic function with 1 method)

   julia> add(6.7, 3.9)
   10.6


Calling a Fortran subroutine is similar to calling a Fortran function. In fact, the subroutine in Fortran can be regarded as a special function, and its return value is void (corresponding to the `Nothing` type in Julia).
Here is another Fortran wrapper example.

.. code-block:: julia

   julia> function addsub(a::Float64, b::Float64)
          x = Ref{Float64}()
          y = Ref{Float64}()
          ccall((:__fortran_julia_MOD_addsub, "fortran_julia.so"), Nothing, (Ref{Float64}, Ref{Float64}, Ref{Float64}, Ref{Float64}), x, y, a, b)
          x[], y[]
          end
   addsub (generic function with 1 method)

   julia> addsub(5.9, 1.5)
   (7.4 4.4)


The Fortran subroutine can pass the calculation results to the caller via modifying the values of input parameters.
In this example, x and y are the output results to the caller.
Therefore two pointers should be defined using `Ref{Float64}()` and then passed to the Fortran subroutine.
After calling the Fortran subroutine, we will use `x[]` and `y[]` to extract the results from the addresses the pre-defined pointers pointing to.
The rest of the this process is similar as calling the Fortran function.


Here is another example to concatenate two strings via calling a Fortran subroutine.

.. code-block:: julia

   julia> function concatenate(a::String, b::String)
          x = Vector{UInt8}(undef, sizeof(a) + sizeof(b))
          ccall((:__fortran_julia_MOD_concatenate, "fortran_julia.so"), Nothing, (Ref{UInt8}, Ref{UInt8}, Ptr{UInt8}, UInt, UInt, UInt), x, Vector{UInt8}(a), b, sizeof(x), sizeof(a), sizeof(b))
          String(x)
          end
   concatenate (generic function with 1 method)

   julia> concatenate("Hello ", "Julia!!!")
   "Hello Julia!!!"


Finally, we have the sample to passing to and fetching an output array from the Fourtran subroutine.

.. code-block:: julia

   julia> function add_array(a::Array{Float64,1}, b::Array{Float64,1})
          x = Array{Float64,1}(undef, length(a))
          ccall((:__fortran_julia_MOD_add_array, "fortran_julia.so"), Nothing, (Ref{Float64}, Ref{Float64}, Ref{Float64}, Ref{UInt32}), x, a, b, length(x))
          x
          end
   add_array (generic function with 1 method)

   julia> add_array([0.2, 1.3, 1.6, 4.6], [-1.8, -0.3, 1.1, 2.4])
   4-element Vector{Float64}:
    -1.6
     1.0
     2.7
     7.0


The :code:`fortran_julia.f90` file and a Jupyter notebook file (`fortran_julia.ipynb`) containing the above examples for interfacing Julia with Fortran are provided in the `github repository <https://github.com/ENCCS/julia-for-hpc/tree/main/content/code>`__.



Interfacing Julia with Python
-----------------------------

Besides interfacing Julia with *compiled* languages like C and Fortran, it is also possible for Julia to have intensive interactions with *interpreted* languages, such as Python, which provide a powerful procedure to leverage the strengths of both languages.


Actually we have came to the interfacing of Julia with Python at the `Setup <https://enccs.github.io/julia-intro/setup/>`_ section in the ENCCS lesson of `Introduction to programming in Julia <https://enccs.github.io/julia-intro/>`_.
We have demonstrated the creation of Jupyter notebooks in Julia using the `IJulia` package.
The Jupyter notebooks support multiple languages, including Julia and Python.
You can write Julia code in one cell and Python code in another, allowing seamless integration.

For specific interactions between Julia and Python, there are two formats, that is, you can call Python from Julia, and you can also call Julia from Python.



Calling Python from Julia
^^^^^^^^^^^^^^^^^^^^^^

The "standard" way to call Python code in Julia is to use the `PyCall <https://github.com/JuliaPy/PyCall.jl>`_ package, which has nice features including:

- It can automatically download and install a local copy of Python, private to Julia, in order to avoid messing with version dependency from the "main" Python installation and provide a consistent environment within Linux, Windows, and MacOS.
- It imports a Python module and provides Julia wrappers for all functions and constants including automatic conversion of types between Julia and Python.
- Type conversions are automatically performed for numeric, boolean, string, and I/O streams plus all tuples, arrays, and dictionaries of these types.











Calling Julia from Python
^^^^^^^^^^^^^^^^^^^^^^







Interfacing Julia with other languages
--------------------------------------

In addition, it is also possible interfacing Julia with other programming languages using third-party packages.
The following table shows an overview of those packages.

.. table:: Interfacing Julia with other languages
   :align: center

   +-----------+--------------------------------------------------------------+---------------------------------------------------------------+
   | Language  | Calling from Julia                                           | Calling Julia                                                 |
   +===========+==============================================================+===============================================================+
   | R         | `RCall.jl <https://github.com/JuliaInterop/RCall.jl>`_       | `JuliaCall <https://github.com/Non-Contradiction/JuliaCall>`_ |
   +-----------+--------------------------------------------------------------+---------------------------------------------------------------+
   | MATLAB    | `MATLAB.jl <https://github.com/JuliaInterop/MATLAB.jl>`_     | `Mex.jl <https://github.com/jebej/Mex.jl/>`_                  |
   +-----------+--------------------------------------------------------------+---------------------------------------------------------------+
   | Java      | `JavaCall.jl <https://github.com/JuliaInterop/JavaCall.jl>`_ | `JuliaCaller <https://github.com/jbytecode/juliacaller>`_     |
   +-----------+--------------------------------------------------------------+---------------------------------------------------------------+

Moreover, other Julia packages provide Julia interface for some well-known libraries from other languages. As an example, we can mention `ScikitLear.jl <https://github.com/cstjean/ScikitLearn.jl>`_, which provides an interface for the `scikit-learn <https://scikit-learn.org/>`_ library from Python or the `RDatasets.jl <https://github.com/JuliaStats/RDatasets.jl>`_ that provides an easy way to load famous R datasets.


See also
--------

- `Julia for Optimization and Learning <https://juliateachingctu.github.io/Julia-for-Optimization-and-Learning/stable/>`__.


.. keypoints::

   - One
