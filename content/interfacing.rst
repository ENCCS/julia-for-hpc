Interfacing to C and Fortran
============================

.. questions::

   - 1
   - 2

.. instructor-note::

   - 20 min teaching
   - 20 min exercises


Why Julia interfacing with other languages?
-------------------------------------------

One of the most significant advantages of Julia is its speed. As we have shown in the Episode
`Motivation <https://enccs.github.io/julia-for-hpc/motivation/#speed>`_, Julia is fast out-of-box
without the necessity to do any additional steps. As such, Julia solves the so-called **two-Language problem**.

Since Julia is fast enough, most of the libraries are written in pure Julia, and there is no need to use C or Fortran for performance.
However, there are many high-quality, mature libraries for numerical computing already written in C and Fortran.
It would be resource-wasting if it is not possible to use them in Julia.

In fact, to allow easy use of existing C and Fortran code, Julia has native support for calling C and Fortran functions.
Julia has a **no boilerplate** philosophy: *functions can be called directly from Julia without any glue code generation
or compilation – even from the interactive prompt*.

In this episode, we will show examples of Julia interfacing with C and Fortran.
Extensive description of all provided functionality can be found in the
`official manual <https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/>`_.


Interfacing Julia with C
------------------------

The interfacing of Julia with C and Fortran is accomplished by making an appropriate call with
the ``ccall`` syntax, which looks like an ordinary function call.

The C and Fortran code to be called must be available as a shared library.
Most C and Fortran libraries ship compiled as shared libraries already.
However, if you want to compile the code yourself using `GCC` (or `Clang`),
you will need to use the `-shared` and `-fPIC` options.
The machine instructions generated by Julia's JIT are the same as a native C call would be,
so the resulting overhead is the same as calling a library function from C code.

By default, Fortran compilers generate mangled names (for example, converting function names to lowercase or uppercase,
often appending an underscore), and so to call a Fortran function you must pass the mangled identifier corresponding
to the rule followed by your Fortran compiler. When calling a Fortran function, all inputs must be passed as pointers
to allocated values on the heap or stack. This applies not only to arrays and other mutable objects which are normally
heap-allocated, but also to scalar values such as integers and floats which are normally stack-allocated and commonly
passed in registers when using C or Julia calling conventions.

When calling C and Fortran functions, the name of the function and the library it lives in
are passed as a tuple in the first argument, followed by the return type of the function and the types
of the function arguments, and finally the argument themselves. It’s a bit klunky, but it works!

Here is one example to calculate the square root of a number (herein, it is 64.0).
.. code-block:: julia

    ccall((:sqrt, "libm"), Float64, (Float64,), 64.0)
    8.0

It also makes sense to wrap a call like that in a native Julia function.
.. code-block:: julia

    csqrt(x) = ccall((:sqrt, "libm"), Float64, (Float64,), x);
    csqrt(81.0)



The following example is adapted from `Calling C from Julia <https://craftofcoding.wordpress.com/2017/02/08/calling-c-from-julia-i-simple-arrays/>`_ by `The Craft of Coding`.
Let's conside the following C function which computes the mean from an array of integer values.
We will name the file as :code:`mean.c`.

.. code-block:: c

   double vectorMean(int *arr, int n)
   {
       int i, sum=0;
       double mean;
       for (i=0; i<n; i=i+1)
           sum = sum + arr[i];
       mean = sum / (double)n;
       return mean;
   }

Next, we need to compile the code in :code:`mean.c` into a shared object named as :code:`mean.so`.
We use the GNU C compiler (GCC) with the flags :code:`-Wall` to enable warnings, :code:`-fpic` to make the shared object relocatable and :code:`-shared` to produce a shared object.
A collection of shared objects is usually referred to as a library.

.. code-block:: bash

   gcc -Wall -fpic -shared -o mean.so mean.c

Now, we can call the shared object from Julia using the :code:`ccall` function as
follows:

.. code-block:: julia

   # Define the array in Julia
   arr = [1,2,3,4,5]

   # Length of the array
   n = length(arr_c)

   # Convert the inputs to native C integer types
   arr_c = collect(Cint, arr)
   n_c = convert(Cint, n)

   # Call the shared library
   ccall((:vectorMean, "./mean.so"), Cdouble, (Ptr{Cint}, Cint), arr_c, n_c)


Interfacing Julia with Fortran
------------------------------


Interfacing Julia with other languages
--------------------------------------


See also
--------

- `Julia for Optimization and Learning <https://juliateachingctu.github.io/Julia-for-Optimization-and-Learning/stable/>`__.


.. keypoints::

   - One
